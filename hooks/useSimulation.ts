
import { useState, useEffect, useCallback } from 'react';
import { RealityEngine } from '../services/simulation';
import type { WorldState, Agent, Entity, EnvironmentState, LogEntry, Culture, Law, Personality, PsychoReport, Election, ActionEffect, LongTermMemory, Relationship, TimedLogEntry } from '../types';
import { initialWorldState, GENOME_OPTIONS, INITIAL_CURRENCY, SKILL_TYPES, defaultPsyche, defaultQTable } from '../constants';
import { generateActionFromPrompt, generateWorld, generateAgents, generateEntities, LmStudioError, generatePsychoanalysis, generateEmbedding } from '../services/geminiService';
import { useLanguage } from '../contexts/LanguageContext';
import { useTranslations } from './useTranslations';
import { useSettings } from '../contexts/SettingsContext';
import { TranslationKey } from '../translations';


// --- Data Sanitization Helpers ---
const safeParseInt = (val: any, fallback: number): number => {
    const num = parseInt(String(val), 10);
    return isNaN(num) ? fallback : num;
};

const sanitizeObjectToNumber = (obj: any): { [key: string]: number } => {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
        return {};
    }
    return Object.entries(obj).reduce((acc, [key, value]) => {
        const num = parseFloat(String(value));
        if (typeof key === 'string' && !isNaN(num)) {
            acc[key] = num;
        }
        return acc;
    }, {} as { [key: string]: number });
};

const sanitizePersonality = (p: any): Personality => {
    const defaults: Personality = { openness: 0.5, conscientiousness: 0.5, extraversion: 0.5, agreeableness: 0.5, neuroticism: 0.5 };
    const sanitized = sanitizeObjectToNumber(p);
    return {
        openness: (sanitized.openness >= 0 && sanitized.openness <= 1) ? sanitized.openness : defaults.openness,
        conscientiousness: (sanitized.conscientiousness >= 0 && sanitized.conscientiousness <= 1) ? sanitized.conscientiousness : defaults.conscientiousness,
        extraversion: (sanitized.extraversion >= 0 && sanitized.extraversion <= 1) ? sanitized.extraversion : defaults.extraversion,
        agreeableness: (sanitized.agreeableness >= 0 && sanitized.agreeableness <= 1) ? sanitized.agreeableness : defaults.agreeableness,
        neuroticism: (sanitized.neuroticism >= 0 && sanitized.neuroticism <= 1) ? sanitized.neuroticism : defaults.neuroticism,
    };
};

const sanitizeAndCreateAgents = (generatedAgents: any[], worldState: WorldState): Agent[] => {
    return generatedAgents.map((geminiAgent: any, index: number) => {
        const beliefNetwork = sanitizeObjectToNumber(geminiAgent.beliefs);
        const personality = sanitizePersonality(geminiAgent.personality);
        
        const defaultSkills = SKILL_TYPES.reduce((acc, skill) => ({ ...acc, [skill]: 1 }), {} as { [key: string]: number });
        const skills = { ...defaultSkills, ...sanitizeObjectToNumber(geminiAgent.skills) };
        
        const defaultEmotions = { happiness: 0.5, sadness: 0.1, anger: 0.1, fear: 0.1, trust: 0.3, love: 0.1 };
        const emotions = { ...defaultEmotions, ...sanitizeObjectToNumber(geminiAgent.emotions) };
        const inventory = typeof geminiAgent.inventory === 'object' && geminiAgent.inventory !== null && !Array.isArray(geminiAgent.inventory) 
            ? sanitizeObjectToNumber(geminiAgent.inventory) 
            : {};

        const x = safeParseInt(geminiAgent.x, Math.floor(Math.random() * worldState.environment.width));
        const y = safeParseInt(geminiAgent.y, Math.floor(Math.random() * worldState.environment.height));
        const age = safeParseInt(geminiAgent.age, 25);
        const hunger = safeParseInt(geminiAgent.hunger, Math.floor(Math.random() * 50));
        const thirst = safeParseInt(geminiAgent.thirst, Math.floor(Math.random() * 50));
        const fatigue = safeParseInt(geminiAgent.fatigue, Math.floor(Math.random() * 50));
        const stress = safeParseInt(geminiAgent.stress, Math.floor(Math.random() * 30));
        const socialStatus = safeParseInt(geminiAgent.socialStatus, Math.floor(Math.random() * 40) + 30);
        const currency = safeParseInt(geminiAgent.currency, INITIAL_CURRENCY);

        return {
            id: `agent-gen-${Date.now()}-${index}`,
            name: String(geminiAgent.name || `Agent ${index + 1}`),
            description: String(geminiAgent.description || 'An agent generated by the AI.'),
            x: Math.max(0, Math.min(worldState.environment.width - 1, x)),
            y: Math.max(0, Math.min(worldState.environment.height - 1, y)),
            beliefNetwork,
            emotions,
            resonance: {},
            socialMemory: [],
            longTermMemory: [],
            lastActions: [],
            adminAgent: false,
            health: 100,
            isAlive: true,
            sickness: null,
            conversationHistory: [],
            age,
            genome: (Array.isArray(geminiAgent.genome) ? geminiAgent.genome : []).filter((g: any) => typeof g === 'string' && GENOME_OPTIONS.includes(g)),
            relationships: {},
            cultureId: geminiAgent.cultureId || null,
            religionId: geminiAgent.religionId || null,
            role: geminiAgent.role || null,
            offspringCount: 0,
            childrenIds: [],
            hunger,
            thirst,
            fatigue,
            inventory,
            personality,
            goals: (Array.isArray(geminiAgent.goals) ? geminiAgent.goals : []).filter((g: any) => typeof g === 'object' && g !== null && g.type && g.description),
            stress,
            socialStatus,
            skills,
            trauma: [],
            psyche: defaultPsyche(),
            currency,
            qTable: defaultQTable(),
            lastStressLevel: stress,
            jailJournal: [],
        };
    });
};

const sanitizeAndCreateEntities = (generatedEntities: any[], worldState: WorldState): Entity[] => {
    return generatedEntities.map((geminiEntity, index) => {
        const x = safeParseInt(geminiEntity.x, Math.floor(Math.random() * worldState.environment.width));
        const y = safeParseInt(geminiEntity.y, Math.floor(Math.random() * worldState.environment.height));
        return {
            id: `entity-gen-${Date.now()}-${index}`,
            name: geminiEntity.name,
            description: geminiEntity.description,
            x: Math.max(0, Math.min(worldState.environment.width - 1, x)),
            y: Math.max(0, Math.min(worldState.environment.height - 1, y)),
            isMarketplace: !!geminiEntity.isMarketplace,
            isJail: !!geminiEntity.isJail,
            isResource: !!geminiEntity.isResource,
            resourceType: geminiEntity.resourceType,
            quantity: safeParseInt(geminiEntity.quantity, 10),
        };
    });
};

export const useSimulation = () => {
    const { settings } = useSettings();
    const [engine, setEngine] = useState(() => new RealityEngine(initialWorldState, settings));
    const [worldState, setWorldState] = useState<WorldState>(engine.getState());
    const [logs, setLogs] = useState<TimedLogEntry[]>([]);
    const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);
    const [isGenerating, setIsGenerating] = useState(false);
    const [isProcessingSteps, setIsProcessingSteps] = useState(false);
    const [isSettingsOpen, setIsSettingsOpen] = useState(false);
    const [isGenerateWorldModalOpen, setIsGenerateWorldModalOpen] = useState(false);
    const [isGenerateContentModalOpen, setIsGenerateContentModalOpen] = useState(false);
  
    // Analytics Dashboard
    const [isAnalyticsOpen, setIsAnalyticsOpen] = useState(false);

    // Psychoanalysis feature
    const [isPsychoanalysisModalOpen, setIsPsychoanalysisModalOpen] = useState(false);
    const [psychoanalysisReport, setPsychoanalysisReport] = useState<PsychoReport | null>(null);
    const [isGeneratingAnalysis, setIsGeneratingAnalysis] = useState(false);
    const [analyzedAgent, setAnalyzedAgent] = useState<Agent | null>(null);
  
    // Panel visibility
    const [panelVisibility, setPanelVisibility] = useState({
      left: true,
      agentCard: true,
      worldMap: true,
      right: true,
    });
  
    const t = useTranslations();
    const { language } = useLanguage();
    
    useEffect(() => {
        setEngine(new RealityEngine(engine.getState(), settings));
    }, [settings]);
  
    const addLog = useCallback((logEntry: LogEntry) => {
        const timedLog: TimedLogEntry = { ...logEntry, timestamp: Date.now() };
        setLogs(prevLogs => [timedLog, ...prevLogs].slice(0, 500));
    }, []);
    
    const addRawLog = useCallback((message: string) => {
       addLog({ key: message });
    }, [addLog]);
  
    useEffect(() => {
        addLog({ key: 'log_simulationInitialized' });
    }, [addLog]);
  
    useEffect(() => {
      const selectedAgentFromState = selectedAgent && worldState.agents.find(a => a.id === selectedAgent.id);
      if (!selectedAgentFromState) {
        setSelectedAgent(worldState.agents[0] || null);
      } else {
        if(JSON.stringify(selectedAgent) !== JSON.stringify(selectedAgentFromState)) {
          setSelectedAgent(selectedAgentFromState);
        }
      }
    }, [worldState.agents, selectedAgent]);
  
    const handleStep = useCallback(async () => {
      setIsProcessingSteps(true);
      try {
          const { logs: newLogs } = await engine.step(language);
          setWorldState({ ...engine.getState() });
          newLogs.forEach(log => addLog(log));
          addLog({ key: 'log_simulationStepped' });
      } catch (error) {
          console.error("Error during step processing:", error);
          addRawLog(`Error during step processing: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
          setIsProcessingSteps(false);
      }
    }, [engine, addLog, language, addRawLog]);
  
    const handleRunSteps = useCallback(async (steps: number) => {
      setIsProcessingSteps(true);
      addRawLog(t('log_runningSimulation', { steps }));
      try {
          let allLogs: LogEntry[] = [];
          for (let i = 0; i < steps; i++) {
            const { logs: newLogs } = await engine.step(language);
            allLogs.push(...newLogs);
          }
          setWorldState({ ...engine.getState() });
          
          const logsWithTimestamp = allLogs.map(log => ({ ...log, timestamp: Date.now() }));
  
          setLogs(prevLogs => [...logsWithTimestamp.reverse(), ...prevLogs].slice(0, 500));
          addLog({ key: 'log_simulationRanSteps', params: { steps } });
      } catch (error) {
          console.error("Error during run steps processing:", error);
          addRawLog(`Error during run steps processing: ${error instanceof Error ? error.message : String(error)}`);
      } finally {
          setIsProcessingSteps(false);
      }
    }, [engine, addLog, addRawLog, t, language]);
  
    const handleReset = useCallback(() => {
      const newEngine = new RealityEngine(initialWorldState, settings);
      setEngine(newEngine);
      setWorldState(newEngine.getState());
      setSelectedAgent(newEngine.getState().agents[0] || null);
      setLogs([{ key: 'log_simulationReset', timestamp: Date.now() }]);
    }, [t, settings]);
  
    const isAiConfigured = useCallback(() => {
      return (settings.provider === 'gemini' && process.env.API_KEY) || (!!settings.lmStudioUrl && !!settings.lmStudioModel);
    }, [settings]);
  
    const handleGenerateWorld = useCallback(async (agentCount: number, entityCounts: { [key: string]: number }) => {
      if (!isAiConfigured()) {
          addRawLog(t('log_configure_ai_full'));
          setIsSettingsOpen(true);
          return;
      }
  
      setIsGenerating(true);
      addRawLog(t('log_generatingWorld'));
  
      try {
          const generatedData = await generateWorld(worldState.environment, language, agentCount, entityCounts);
  
          if (!generatedData || !generatedData.agents || !generatedData.entities) throw new Error("Invalid data from world generation.");
          
          const totalEntityCount = Object.values(entityCounts).reduce((sum, val) => sum + val, 0);
          if (generatedData.agents.length !== agentCount || generatedData.entities.length !== totalEntityCount) {
              addRawLog(t('log_worldGenerated_warning', { reqAgents: agentCount, genAgents: generatedData.agents.length, reqEntities: totalEntityCount, genEntities: generatedData.entities.length }));
          }
  
          const newAgents: Agent[] = sanitizeAndCreateAgents(generatedData.agents, worldState);
          const adminAgent = engine.getAgentById('agent-admin');
          
          // Post-processing step to create initial relationships
          const processedPairs = new Set<string>();
          newAgents.forEach(agentA => {
              if (!agentA.relationships) agentA.relationships = {};
              newAgents.forEach(agentB => {
                  if (agentA.id === agentB.id) return;
                  const pairKey = [agentA.id, agentB.id].sort().join('-');
                  if (processedPairs.has(pairKey)) return;

                  const distance = Math.sqrt(Math.pow(agentA.x - agentB.x, 2) + Math.pow(agentA.y - agentB.y, 2));
                  let score = 0;
                  let type: Relationship['type'] = 'stranger';
                  if (distance < 5) {
                      score = 35;
                      type = 'acquaintance';
                  } else if (distance < 10) {
                      score = 15;
                  }

                  if (score > 0) {
                       if (!agentA.relationships) agentA.relationships = {};
                       if (!agentB.relationships) agentB.relationships = {};
                       
                       const relationship = { type, score, disposition: {} };
                       agentA.relationships[agentB.id] = relationship;
                       agentB.relationships[agentA.id] = relationship;
                  }
                  processedPairs.add(pairKey);
              });
          });

          // Post-processing: Make all new agents friends with the Admin
          if (adminAgent) {
              newAgents.forEach(agent => {
                  if (!agent.adminAgent) {
                      if (!agent.relationships) agent.relationships = {};
                      agent.relationships[adminAgent.id] = { type: 'friend', score: 100, disposition: {} };

                      if (!adminAgent.relationships) adminAgent.relationships = {};
                      adminAgent.relationships[agent.id] = { type: 'friend', score: 100, disposition: {} };
                  }
              });
          }

          const newEntities: Entity[] = sanitizeAndCreateEntities(generatedData.entities, worldState);
          
          const finalAgents = adminAgent ? [...newAgents, adminAgent] : newAgents;
  
          const currentEngineState = engine.getState();
          const newWorldState: WorldState = { ...currentEngineState, agents: finalAgents, entities: newEntities };
          
          const newEngine = new RealityEngine(newWorldState, settings);
          setEngine(newEngine);
          setWorldState(newEngine.getState());
          setSelectedAgent(newEngine.getState().agents.find(a => !a.adminAgent) || null);
          addRawLog(t('log_worldGenerated'));
  
      } catch (error) {
          if (error instanceof LmStudioError && error.translationKey) addRawLog(t(error.translationKey as TranslationKey));
          else addRawLog(t('log_aiError', { error: `World generation failed: ${error instanceof Error ? error.message : String(error)}` }));
      } finally {
          setIsGenerating(false);
      }
    }, [engine, addRawLog, t, language, worldState, settings, isAiConfigured]);
  
    const handleGenerateAgents = useCallback(async (count: number) => {
      if (!isAiConfigured()) {
          addRawLog(t('log_configure_ai_full'));
          setIsSettingsOpen(true);
          return;
      }
  
      setIsGenerating(true);
      addRawLog(t('log_generatingAgents', { count }));
      setIsGenerateContentModalOpen(false);
  
      try {
          const generatedData = await generateAgents(worldState.environment, language, count);
          if (!generatedData || !generatedData.agents) throw new Error("Invalid data from agent generation.");
          
          const newAgents = sanitizeAndCreateAgents(generatedData.agents, worldState);
          
          const adminAgent = engine.getAgentById('agent-admin');
          if (adminAgent) {
              newAgents.forEach(agent => {
                  if (!agent.relationships) agent.relationships = {};
                  agent.relationships[adminAgent.id] = { type: 'friend', score: 100, disposition: {} };
                  if (!adminAgent.relationships) adminAgent.relationships = {};
                  adminAgent.relationships[agent.id] = { type: 'friend', score: 100, disposition: {} };
              });
          }
          
          newAgents.forEach(agent => {
              engine.addNewSanitizedAgent(agent);
          });
          setWorldState({ ...engine.getState() });
          
          addRawLog(t('log_addedAgents', { count: newAgents.length }));
  
      } catch (error) {
          if (error instanceof LmStudioError && error.translationKey) addRawLog(t(error.translationKey as TranslationKey));
          else addRawLog(t('log_aiError', { error: `Agent generation failed: ${error instanceof Error ? error.message : String(error)}` }));
      } finally {
          setIsGenerating(false);
      }
    }, [engine, addRawLog, t, language, worldState, settings, isAiConfigured]);
  
    const handleGenerateEntities = useCallback(async (counts: { [key: string]: number }) => {
        if (!isAiConfigured()) {
            addRawLog(t('log_configure_ai_full'));
            setIsSettingsOpen(true);
            return;
        }

        setIsGenerating(true);
        const totalCount = Object.values(counts).reduce((sum, val) => sum + val, 0);
        addRawLog(t('log_generatingEntities', { count: totalCount }));
        setIsGenerateContentModalOpen(false);

        try {
            const generatedData = await generateEntities(worldState.environment, language, counts);
            if (!generatedData || !generatedData.entities) throw new Error("Invalid data from entity generation.");

            const newEntities = sanitizeAndCreateEntities(generatedData.entities, worldState);
            
            newEntities.forEach(entity => {
                engine.addNewSanitizedEntity(entity);
            });
            setWorldState({ ...engine.getState() });

            addRawLog(t('log_addedEntities', { count: newEntities.length }));

        } catch (error) {
            if (error instanceof LmStudioError && error.translationKey) addRawLog(t(error.translationKey as TranslationKey));
            else addRawLog(t('log_aiError', { error: `Entity generation failed: ${error instanceof Error ? error.message : String(error)}` }));
        } finally {
            setIsGenerating(false);
        }
    }, [engine, addRawLog, t, language, worldState, settings, isAiConfigured]);

    const handlePrompt = useCallback(async (agentId: string, prompt: string, useAi: boolean) => {
      const agent = engine.getAgentById(agentId);
      if (!agent) return;

      if (!isAiConfigured()) {
          addRawLog(t('log_configure_ai_full'));
          setIsSettingsOpen(true);
          return;
      }
  
      setIsProcessingSteps(true);
      addLog({ key: 'log_agentProcessingPrompt', params: { agentId, prompt, aiInfo: useAi ? 'AI' : 'Direct' } });
  
      try {
          if (useAi) {
              const memoryDB = engine.searchAgentMemory(agentId, await generateEmbedding(prompt, settings), 5);
              const recalledMemories = memoryDB.map(m => `[T-${worldState.environment.time - m.timestamp}] ${m.content}`);
              const actionName = await generateActionFromPrompt(prompt, engine.getAvailableActions(), agent, worldState, language, recalledMemories);
              if (actionName && actionName !== 'Keine Aktion') {
                  addLog({ key: 'log_aiSuggestedAction', params: { action: actionName } });
                  const { logs: newLogs } = await engine.processAgentPrompt(agentId, actionName);
                  newLogs.forEach(addLog);
              } else {
                  addLog({ key: 'log_aiFailed' });
              }
          } else {
              const { logs: newLogs } = await engine.processAgentPrompt(agentId, prompt);
              newLogs.forEach(addLog);
          }
          setWorldState({ ...engine.getState() });
      } catch (error) {
           if (error instanceof LmStudioError && error.translationKey) addRawLog(t(error.translationKey as TranslationKey));
           else addRawLog(t('log_aiError', { error: (error as Error).message }));
      } finally {
          setIsProcessingSteps(false);
      }
    }, [engine, addLog, t, language, worldState, isAiConfigured, addRawLog, settings]);
  
    const handleExport = (type: 'environment' | 'agents' | 'entities' | 'all') => {
      const state = engine.getState();
      let data;
      let filename = `reality_sim_export_${type}.json`;
      if (type === 'all') {
        data = state;
        filename = `reality_sim_save_${new Date().toISOString()}.json`;
      } else {
        data = state[type];
      }
  
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      addLog({ key: type === 'all' ? 'log_stateSaved' : 'log_exported', params: { type } });
    };

    const handleExportConversations = useCallback(() => {
        const state = engine.getState();
        let markdownString = "# Conversation Histories\n\n";

        state.agents.forEach(agent => {
            if (agent.conversationHistory && agent.conversationHistory.length > 0) {
                markdownString += `## Agent: ${agent.name}\n\n`;
                agent.conversationHistory.forEach(h => {
                    markdownString += `- **${h.speakerName}:** "${h.message}"\n`;
                });
                markdownString += `\n---\n\n`;
            }
        });

        const blob = new Blob([markdownString], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `reality_sim_conversations_${new Date().toISOString()}.md`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        addLog({ key: 'export_conversations' as any });
    }, [engine, addLog]);
  
    const handleLoadState = () => {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const loadedState = JSON.parse(event.target?.result as string);
              // Merge with initial state to ensure all keys are present for robustness with older save files
              const mergedState: WorldState = {
                  ...initialWorldState,
                  ...loadedState,
                  environment: { ...initialWorldState.environment, ...(loadedState.environment || {}) },
                  government: { ...initialWorldState.government, ...(loadedState.government || {}) },
                  agents: loadedState.agents || initialWorldState.agents,
                  entities: loadedState.entities || initialWorldState.entities,
                  actions: loadedState.actions || initialWorldState.actions,
                  cultures: loadedState.cultures || initialWorldState.cultures,
                  religions: loadedState.religions || initialWorldState.religions,
                  markets: loadedState.markets || initialWorldState.markets,
                  techTree: loadedState.techTree || initialWorldState.techTree,
                  transactions: loadedState.transactions || initialWorldState.transactions,
              };
              const newEngine = new RealityEngine(mergedState, settings);
              setEngine(newEngine);
              setWorldState(newEngine.getState());
              setSelectedAgent(newEngine.getState().agents[0] || null);
              addLog({ key: 'log_stateLoaded' });
            } catch (error) {
              addLog({ key: 'log_loadError', params: { error: (error as Error).message } });
            }
          };
          reader.readAsText(file);
        }
      };
      input.click();
    };

    const handleGeneratePsychoanalysis = useCallback(async (agent: Agent) => {
        if (!isAiConfigured()) {
            addRawLog(t('log_configure_ai_full'));
            setIsSettingsOpen(true);
            return;
        }

        setAnalyzedAgent(agent);
        setIsPsychoanalysisModalOpen(true);
        setIsGeneratingAnalysis(true);
        setPsychoanalysisReport(null);

        try {
            const report = await generatePsychoanalysis(agent, worldState, language);
            setPsychoanalysisReport(report);
            if (report) {
                const { logs } = engine.applyPsychoanalysis(agent.id, report);
                logs.forEach(addLog);
                setWorldState({ ...engine.getState() });
            }
        } catch (error) {
             if (error instanceof LmStudioError && error.translationKey) addRawLog(t(error.translationKey as TranslationKey));
             else addRawLog(t('log_aiError', { error: `Psychoanalysis failed: ${error instanceof Error ? error.message : String(error)}` }));
        } finally {
            setIsGeneratingAnalysis(false);
        }
    }, [engine, worldState, language, addLog, addRawLog, t, isAiConfigured]);

    const handleExportStatistics = useCallback(() => {
        const stats = {
            marriages: {} as { [pair: string]: number },
            births: [] as { parents: string, child: string }[],
            imprisonments: {} as { [agent: string]: number },
            fights: {} as { [pair:string]: number },
        };

        // Iterate chronologically
        [...logs].reverse().forEach(log => {
            const p = log.params || {};
            switch (log.key) {
                case 'log_action_accept_proposal_success': {
                    const pair = [p.agentName, p.targetName].sort().join(' & ');
                    stats.marriages[pair] = (stats.marriages[pair] || 0) + 1;
                    break;
                }
                case 'log_new_child': {
                    stats.births.push({
                        parents: [p.parent1Name, p.parent2Name].sort().join(' & '),
                        child: p.childName,
                    });
                    break;
                }
                case 'log_action_arrest_success': {
                    stats.imprisonments[p.criminalName] = (stats.imprisonments[p.criminalName] || 0) + 1;
                    break;
                }
                case 'log_action_fight': {
                    const pair = [p.agentName1, p.agentName2].sort().join(' & ');
                    stats.fights[pair] = (stats.fights[pair] || 0) + 1;
                    break;
                }
            }
        });

        let md = `# ${t('stats_report_title')}\n\n`;

        md += `## ${t('stats_marriages')}\n`;
        if (Object.keys(stats.marriages).length > 0) {
            Object.entries(stats.marriages).forEach(([pair, count]) => {
                md += `- ${pair} (x${count})\n`;
            });
        } else {
            md += `- None\n`;
        }
        md += `\n`;

        md += `## ${t('stats_births')}\n`;
        if (stats.births.length > 0) {
            stats.births.forEach(birth => {
                md += `- ${birth.child} (Parents: ${birth.parents})\n`;
            });
        } else {
            md += `- None\n`;
        }
        md += `\n`;

        md += `## ${t('stats_imprisonments')}\n`;
        if (Object.keys(stats.imprisonments).length > 0) {
            Object.entries(stats.imprisonments)
                .sort((a, b) => b[1] - a[1])
                .forEach(([agent, count]) => {
                    md += `- ${agent}: ${count} times\n`;
                });
        } else {
            md += `- None\n`;
        }
        md += `\n`;

        md += `## ${t('stats_fights')}\n`;
        if (Object.keys(stats.fights).length > 0) {
             Object.entries(stats.fights)
                .sort((a, b) => b[1] - a[1])
                .forEach(([pair, count]) => {
                    md += `- ${pair}: ${count} times\n`;
                });
        } else {
            md += `- None\n`;
        }
        md += `\n`;

        const blob = new Blob([md], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `reality_sim_statistics_${new Date().toISOString()}.md`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        addLog({ key: 'export_statistics' as any });
    }, [logs, t, addLog]);

    const handleCreate = useCallback((type: 'agent' | 'entity' | 'action', data: any) => {
      if (type === 'agent') {
        engine.addAgent(data.name, data.description, data.beliefs || {}, data.genome || [], data.role, data.personality);
        addLog({ key: 'log_createdAgent', params: { name: data.name } });
      } else if (type === 'entity') {
        engine.addEntity(data.name, data.description);
        addLog({ key: 'log_createdEntity', params: { name: data.name } });
      } else if (type === 'action') {
        engine.addAction(data.name, data.description, data.beliefKey, data.effects);
        addLog({ key: 'log_createdAction', params: { name: data.name } });
      }
      setWorldState({ ...engine.getState() });
    }, [engine, addLog]);
  
    const handleDelete = useCallback((type: 'agent' | 'entity' | 'action', id: string) => {
      const name = type === 'agent' ? worldState.agents.find(a => a.id === id)?.name :
                   type === 'entity' ? worldState.entities.find(e => e.id === id)?.name : id;
                   
      if (window.confirm(t('confirmDelete', { type: t(`type_${type}` as TranslationKey) }))) {
        if (type === 'agent') engine.removeAgent(id);
        else if (type === 'entity') engine.removeEntity(id);
        else if (type === 'action') engine.removeAction(id);
        
        setWorldState({ ...engine.getState() });
        addLog({ key: 'log_removed', params: { type: t(`type_${type}` as TranslationKey), name: name || id } });
      }
    }, [engine, worldState.agents, worldState.entities, addLog, t]);
  
    const handleUpdateEnvironment = useCallback((newEnv: EnvironmentState) => {
      engine.setEnvironment(newEnv);
      setWorldState({ ...engine.getState() });
      addLog({ key: 'log_adminModifiedEnv' });
    }, [engine, addLog]);

    const handleSetAgentHealth = useCallback((agentId: string, health: number) => {
      engine.setAgentHealth(agentId, health);
      const agent = engine.getAgentById(agentId);
      setWorldState({ ...engine.getState() });
      addLog({ key: 'log_adminSetHealth', params: { name: agent?.name, health } });
    }, [engine, addLog]);

    const handleInflictSickness = useCallback((agentId: string, sickness: string | null) => {
      engine.setAgentSickness(agentId, sickness);
      const agent = engine.getAgentById(agentId);
      setWorldState({ ...engine.getState() });
      if(sickness) addLog({ key: 'log_adminInflictedSickness', params: { name: agent?.name, sickness } });
      else addLog({ key: 'log_adminCured', params: { name: agent?.name } });
    }, [engine, addLog]);
    
    const handleResurrectAgent = useCallback((agentId: string) => {
        engine.resurrectAgent(agentId);
        const agent = engine.getAgentById(agentId);
        setWorldState({...engine.getState()});
        addLog({ key: 'log_adminResurrected', params: { name: agent?.name } });
    }, [engine, addLog]);

    const handleSetAgentPosition = useCallback((agentId: string, x: number, y: number) => {
        engine.setAgentPosition(agentId, x, y);
        const agent = engine.getAgentById(agentId);
        setWorldState({...engine.getState()});
        addLog({ key: 'log_adminSetPosition', params: { name: agent?.name, x, y }});
    }, [engine, addLog]);

    const handleSetAgentCurrency = useCallback((agentId: string, currency: number) => {
        engine.setAgentCurrency(agentId, currency);
        const agent = engine.getAgentById(agentId);
        setWorldState({...engine.getState()});
        addLog({ key: 'log_adminSetCurrency', params: { name: agent?.name, currency }});
    }, [engine, addLog]);

    const handleImprisonAgent = useCallback((agentId: string, duration: number) => {
        const success = engine.imprisonAgent(agentId, duration);
        if (success) {
            const agent = engine.getAgentById(agentId);
            setWorldState({ ...engine.getState() });
            addLog({ key: 'log_adminImprisoned', params: { name: agent?.name, duration } });
        }
    }, [engine, addLog]);
    
    const handleEnactLaw = useCallback((law: Law) => {
        engine.enactLaw(law);
        setWorldState({...engine.getState()});
        addLog({ key: 'log_action_enact_law_success', params: { agentName: 'Admin', lawName: law.name }});
    }, [engine, addLog]);

    const handleRepealLaw = useCallback((lawId: string) => {
        const lawName = worldState.government.laws.find(l=>l.id===lawId)?.name || 'Unknown Law';
        engine.repealLaw(lawId);
        setWorldState({...engine.getState()});
        addLog({ key: 'log_adminRepealedLaw', params: { lawName }});
    }, [engine, addLog, worldState.government.laws]);

    const handleStartElection = useCallback(() => {
        engine.startElection();
        setWorldState({...engine.getState()});
        addLog({ key: 'log_election_started' });
    }, [engine, addLog]);

    const handleSetLeader = useCallback((agentId: string) => {
        const agentName = engine.getAgentById(agentId)?.name || 'Unknown';
        const { techUnlocked, cultureName } = engine.setLeader(agentId);
        setWorldState({...engine.getState()});
        addLog({ key: 'log_adminSetLeader', params: { name: agentName }});
        if (techUnlocked) {
            addLog({ key: 'log_leader_unlocks_governance', params: { leaderName: agentName, cultureName } });
        }
    }, [engine, addLog]);

    const handleUnlockTech = useCallback((cultureId: string, techId: string) => {
        engine.unlockTech(cultureId, techId);
        const cultureName = worldState.cultures.find(c=>c.id === cultureId)?.name || 'Unknown';
        setWorldState({...engine.getState()});
        addLog({ key: 'log_adminUnlockedTech', params: { techId, cultureName }});
    }, [engine, addLog, worldState.cultures]);

    const togglePanel = useCallback((panel: keyof typeof panelVisibility) => {
      setPanelVisibility(prev => ({ ...prev, [panel]: !prev[panel] }));
    }, []);

    const handlers = {
        handleStep, handleRunSteps, handleReset, handlePrompt, handleExport, handleLoadState,
        handleExportConversations, handleCreate, handleDelete, handleUpdateEnvironment, 
        handleGenerateWorld, handleGenerateAgents, handleGenerateEntities,
        handleGeneratePsychoanalysis, handleSetAgentHealth, handleInflictSickness, handleResurrectAgent, handleSetAgentPosition,
        handleSetAgentCurrency, handleEnactLaw, handleRepealLaw, handleStartElection, handleSetLeader, handleUnlockTech,
        handleImprisonAgent, handleExportStatistics
    };
    
    return {
        worldState,
        logs,
        selectedAgent,
        isGenerating,
        isProcessingSteps,
        isSettingsOpen,
        isGenerateWorldModalOpen,
        isGenerateContentModalOpen,
        isAnalyticsOpen,
        isPsychoanalysisModalOpen,
        psychoanalysisReport,
        isGeneratingAnalysis,
        analyzedAgent,
        panelVisibility,
        setSelectedAgent,
        setIsSettingsOpen,
        setIsGenerateWorldModalOpen,
        setIsGenerateContentModalOpen,
        setIsAnalyticsOpen,
        setIsPsychoanalysisModalOpen,
        togglePanel,
        handlers,
    };
}